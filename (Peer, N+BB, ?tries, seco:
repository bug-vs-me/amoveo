diff --git a/apps/amoveo_core/src/consensus/chain/block.erl b/apps/amoveo_core/src/consensus/chain/block.erl
index 4141cdb..99a8f42 100644
--- a/apps/amoveo_core/src/consensus/chain/block.erl
+++ b/apps/amoveo_core/src/consensus/chain/block.erl
@@ -96,7 +96,11 @@ calculate_prev_hashes([PH|Hashes], Height, N) ->
     end.
 get_by_hash(H) -> 
     Hash = hash(H),
-    block_db:read(Hash).
+    case block_db:read(Hash) of
+        error -> empty;
+        X -> X
+    end.
+            
 %    BlockFile = amoveo_utils:binary_to_file_path(blocks, Hash),
 %    case db:read(BlockFile) of
 %        [] -> empty;
diff --git a/apps/amoveo_core/src/consensus/chain/block_absorber.erl b/apps/amoveo_core/src/consensus/chain/block_absorber.erl
index 34833e6..ab885cd 100644
--- a/apps/amoveo_core/src/consensus/chain/block_absorber.erl
+++ b/apps/amoveo_core/src/consensus/chain/block_absorber.erl
@@ -137,7 +137,9 @@ absorb_internal(Block) ->
 			    order_book:match();
 			    %sync:push_new_block(Block2);
 			quick -> 
-			    recent_blocks:add(BH, Header#header.accumulative_difficulty, Height),%garbage collection
+                            spawn(fun() ->
+                                          recent_blocks:add(BH, Header#header.accumulative_difficulty, Height)%garbage collection
+                                  end),
 			    %0.45 0.4 0.3
 			    %io:fwrite("block absorber 6\n"),
 			    %io:fwrite(packer:pack(erlang:timestamp())),
diff --git a/apps/amoveo_core/src/consensus/chain/block_db.erl b/apps/amoveo_core/src/consensus/chain/block_db.erl
index 5ac402a..a661b49 100644
--- a/apps/amoveo_core/src/consensus/chain/block_db.erl
+++ b/apps/amoveo_core/src/consensus/chain/block_db.erl
@@ -2,13 +2,14 @@
 -behaviour(gen_server).
 -export([start_link/0,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2,
          read/1, read/2, write/2,
+         uncompress/1, compress/1,
          check/0,
          test/0]).
 -define(LOC, constants:block_db_dict()).
 -define(blocks_loc, constants:blocks_file2()).
 -define(ram_limit, 20000000).%20 megabytes
 %-define(ram_limit, 10000).
--define(version, old).
+-define(version, new).
 -record(d, {dict = dict:new(), 
             many_blocks = 0,
             page_number = 0,
@@ -56,7 +57,7 @@ handle_call({read, Hash}, _From, X) ->
                     is_integer(N) -> %block on the hard drive.
                         {Loc, Size} = dict:fetch(N, X#d.pages),
                         {ok, Data} = read_page(Loc, Size, X#d.blocks_hd),
-                        P = binary_to_term(zlib:uncompress(Data)),
+                        P = uncompress(Data),
                         dict:fetch(Hash, P);
                     true -> N %a block in ram
                 end
@@ -88,10 +89,24 @@ read_page(Loc, Size, File) ->
     file:pread(File, Loc, Size).
 write_page(Dict, X) ->
     B = X#d.hd_bytes,
-    Data = zlib:compress(term_to_binary(Dict)),
+    Data = compress(Dict),
     S = size(Data),
     file:pwrite(X#d.blocks_hd, B, Data),
     {B, S}.
+
+compress(X) ->
+    S = zlib:open(),
+    zlib:deflateInit(S, 9),
+    B1 = zlib:deflate(S, term_to_binary(X)),
+    B2 = zlib:deflate(S, <<>>, finish),
+    %zlib:compress(term_to_binary(X)).
+    list_to_binary([B1, B2]).
+uncompress(X) ->
+    S = zlib:open(),
+    zlib:inflateInit(S),
+    binary_to_term(list_to_binary(zlib:inflate(S, X))).
+    %binary_to_term(zlib:uncompress(X)).
+    
             
 
 % * starting from the head, walk backwards FT steps. everything earlier than that block is going to the hd.
@@ -181,7 +196,7 @@ test() ->
     X = #d{blocks_hd = F},
     {Loc, Size} = write_page(NewDict, X),
     {ok, Data} = read_page(Loc, Size, X#d.blocks_hd),
-    NewDict = binary_to_term(zlib:uncompress(Data)).
+    uncompress(Data).
     
 
 
@@ -235,7 +250,7 @@ read(Hash) ->
             BlockFile = binary_to_file_path(blocks, Hash),
             case db:read(BlockFile) of
                 [] -> empty;
-                Block -> binary_to_term(zlib:uncompress(Block))
+                Block -> uncompress(Block)
             end;
         new ->
             gen_server:call(?MODULE, {read, Hash})
@@ -244,7 +259,7 @@ read(Hash) ->
 write(Block, Hash) ->
     case ?version of
         old ->
-            CompressedBlockPlus = zlib:compress(term_to_binary(Block)),
+            CompressedBlockPlus = compress(Block),
                                                 %Hash = block:hash(Block),
             BlockFile = binary_to_file_path(blocks, Hash),
             ok = db:save(BlockFile, CompressedBlockPlus);
diff --git a/apps/amoveo_core/src/consensus/chain/block_organizer.erl b/apps/amoveo_core/src/consensus/chain/block_organizer.erl
index a684f03..9ce9eab 100644
--- a/apps/amoveo_core/src/consensus/chain/block_organizer.erl
+++ b/apps/amoveo_core/src/consensus/chain/block_organizer.erl
@@ -1,20 +1,25 @@
 -module(block_organizer).
 -behaviour(gen_server).
 -export([start_link/0,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2,
-	add/1, check/0, view/0, pid/0]).
+         top/0, add/1, check/0, view/0, pid/0]).
 -include("../../records.hrl").
-init(ok) -> {ok, []}.
+-record(d, {blocks = [], top = 0}).
+init(ok) -> {ok, #d{}}.
 start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
 code_change(_OldVsn, State, _Extra) -> {ok, State}.
 terminate(_, _) -> io:format("died!"), ok.
 handle_info(_, X) -> {noreply, X}.
 handle_cast(check, BS) -> 
-    BS2 = helper(BS),
+    B2 = helper(BS#d.blocks),
+    BS2 = BS#d{blocks = B2},
     {noreply, BS2}.
 handle_call({add, Blocks}, _From, BS) -> 
-    BS2 = merge(Blocks, BS),
-    BS3 = helper(BS2), 
+    BS2 = merge(Blocks, BS#d.blocks, [], BS#d.top),
+    B2 = helper(BS2#d.blocks), 
+    BS3 = BS2#d{blocks = B2},
     {reply, ok, BS3};
+handle_call(top, _From, BS) -> 
+    {reply, BS#d.top, BS};
 handle_call(pid, _From, X) -> 
     {reply, self(), X};
 handle_call(view, _, BS) -> 
@@ -24,16 +29,21 @@ handle_call(_, _From, X) -> {reply, X, X}.
 pid() -> gen_server:call(?MODULE, pid).
 view() ->
     gen_server:call(?MODULE, view).
-merge(New, []) -> [New];%merge sort
-merge([], Old) -> Old;
-merge([N|NT], [O|OT]) ->
+merge(New, [], L, T) -> #d{blocks = L ++ [New], 
+                        top = T};%merge sort
+merge([], Old, L, T) -> #d{blocks = L ++ Old,
+                        top = T};
+merge([N|NT], [O|OT], L, Top) ->
     %HN = hd(N),
     HO = hd(O),
     H1 = N#block.height,
     H2 = HO#block.height,
+    NewTop = max(H1, max(Top, H2)),
     if
-	H2 < H1 -> [O|merge([N|NT], OT)];
-	true -> [[N|NT]|[O|OT]]
+	H2 < H1 -> 
+            merge([N|NT], OT, L ++ [O], NewTop);
+	true -> #d{blocks = L ++ [[N|NT]|[O|OT]],
+                   top = NewTop}
     end.
 helper([]) -> [];
 helper([[]]) -> [];
@@ -45,7 +55,11 @@ helper([H|T]) ->
     H2 = HH#block.height,
     if
 	H2 =< MyHeight + 1 ->
-	    block_absorber:save(H),%maybe this should be a cast.
+            %spawn(fun() ->
+            block_absorber:save(H),%maybe this should be a cast.
+                          %check(),
+            %              ok end),
+            %T;
 	    helper(T);
 	true -> [H|T]
     end.
@@ -57,19 +71,34 @@ add(Blocks) ->
     %io:fwrite("block organizer add\n"),
     true = is_list(Blocks),
     {Blocks2, AddReturn} = add1(Blocks, []),
-    add3(Blocks2),
+    add3(lists:reverse(Blocks2)),
     AddReturn.
 add3([]) -> ok;
-add3(Blocks) when length(Blocks) > 10 ->
-    {A, B} = lists:split(10, Blocks),
+add3(Blocks)->
+    %{A, B} = lists:split(10, Blocks),
+    {A, B} = lists:split(min(100, length(Blocks)), Blocks),
     add4(A),
-    add3(B);
-add3(Blocks) -> add4(Blocks).
+    %timer:sleep(5),
+    add3(B).
+%add3(Blocks) -> add4(Blocks).
 add4(Blocks) ->
     spawn(fun() ->
+                  S = "block organizer add4, height: " ++ (integer_to_list(element(2, hd(Blocks)))) ++ ("\n"),
+                  io:fwrite(S),
+                  %io:fwrite(packer:pack(hd(Blocks))),
+                  %io:fwrite("\n"),
+                  %io:fwrite(integer_to_list(element(2, hd(Blocks)))),
+                  %io:fwrite(" "),
+                  %io:fwrite(integer_to_list(element(2, hd(lists:reverse(Blocks))))),
+                  %io:fwrite("\n"),
+                  %io:fwrite("block organizer add4, many: "),
+                  %io:fwrite(integer_to_list(length(Blocks))),
 		  Blocks2 = add5(Blocks),
-		  gen_server:call(?MODULE, {add, lists:reverse(Blocks2)})
+                  %io:fwrite("block organizer add4 2\n"),
+		  %gen_server:call(?MODULE, {add, lists:reverse(Blocks2)})
+		  gen_server:call(?MODULE, {add, Blocks2})
 	  end).
+top() -> gen_server:call(?MODULE, top).
 add5([]) -> [];
 add5([Block|T]) ->
     {Dict, NewDict, BlockHash} = block:check0(Block),
diff --git a/apps/amoveo_core/src/consensus/sync.erl b/apps/amoveo_core/src/consensus/sync.erl
index e600646..8511c7d 100644
--- a/apps/amoveo_core/src/consensus/sync.erl
+++ b/apps/amoveo_core/src/consensus/sync.erl
@@ -16,7 +16,7 @@ start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
 code_change(_OldVsn, State, _Extra) -> {ok, State}.
 terminate(_, _) -> io:format("sync died!\n"), ok.
 handle_info(_, X) -> {noreply, X}.
-%handle_cast(start, _) -> {noreply, go};
+handle_cast(start, _) -> {noreply, go};
 %handle_cast(stop, _) -> {noreply, stop};
 handle_cast({main, Peer}, _) -> 
     BL = case application:get_env(amoveo_core, kind) of
@@ -232,10 +232,10 @@ get_blocks(Peer, N, Tries, Time, TheirBlockHeight) ->
 	    %io:fwrite("\n"),
 	    Many = min(BB, TheirBlockHeight - N + 1),
 	    spawn(fun() ->
-                          %get_blocks2(TheirBlockHeight, Many, N, Peer, 5)
-                          get_blocks2(TheirBlockHeight, Many, N, Peer, 1)
+                          get_blocks2(TheirBlockHeight, Many, N, Peer, 5)
+                          %get_blocks2(TheirBlockHeight, Many, N, Peer, 1)
 		  end),
-	    %timer:sleep(100),
+	    timer:sleep(1000),
 	    if
 		Many == BB ->
 		    get_blocks(Peer, N+BB, ?tries, second, TheirBlockHeight);
@@ -247,26 +247,29 @@ get_blocks2(_, _BB, _N, _Peer, 0) ->
     ok;
 get_blocks2(TheirBlockHeight, BB, N, Peer, Tries) ->
     %N should not be above our current height.
+    %BH0 = block_organizer:top(),
     BH0 = block:height(),
     true = BH0 < (N+1),
-    %io:fwrite("get blocks 2\n"),
+    io:fwrite("get blocks 2\n"),
     go = sync_kill:status(),
     BD = N+1 - BH0,
     if
-        BD < 300 ->
-            timer:sleep(2000);
-        true ->
-            timer:sleep(200)
+        BD < 300 -> %ok;
+            timer:sleep(0);
+        true -> %ok
+            timer:sleep(300)
     end,
     BH = block:height(),
-    %io:fwrite(packer:pack([BH, N+1])),
-    %io:fwrite("\n"),
+    %BH = block_organizer:top(),
+    io:fwrite(packer:pack([BH, N+1])),
+    io:fwrite("\n"),
     true = BH < (N+1),
-    %io:fwrite("get blocks 2, download blocks\n"),
-    %io:fwrite(integer_to_list(N)),
-    %io:fwrite("\n"),
+    io:fwrite("get blocks 2, download blocks\n"),
+    io:fwrite(integer_to_list(N)),
+    io:fwrite("\n"),
     Blocks = talker:talk({blocks, BB, N}, Peer),
     BH2 = block:height(),
+    %BH2 = block_organizer:top(),
     true = BH2 < (N+1),
     %io:fwrite("get blocks 2, sync blocks\n"),
     %io:fwrite(integer_to_list(N)),
@@ -281,48 +284,65 @@ get_blocks2(TheirBlockHeight, BB, N, Peer, Tries) ->
 	    timer:sleep(Sleep),
 	    get_blocks2(TheirBlockHeight, BB, N, Peer, Tries - 1);
 	bad_peer -> 
-	    %io:fwrite("get blocks 2 failed connect bad peer\n"),
+	    io:fwrite("get blocks 2 failed connect bad peer\n"),
 	    %io:fwrite(packer:pack([BB, N, Peer, Tries])),
-	    %io:fwrite("\n"),
-	    1=2;
+	    io:fwrite("\n"),
+	    timer:sleep(Sleep),
+	    get_blocks2(TheirBlockHeight, BB, N, Peer, Tries - 1);
+	    %1=2;
 	    %timer:sleep(Sleep),
 	    %get_blocks2(BB, N, Peer, Tries - 1);
 	{ok, Bs} -> 
             if
                 is_list(Bs) ->
                     block_organizer:add(Bs);
+                false ->
+                    wait_do(fun() ->
+                                    (N + length(Bs)) < (block:height() + 8000)
+                            end,
+                            fun() ->
+                                    io:fwrite("wait do call \n"),
+                                    get_blocks2(TheirBlockHeight, BB, N + length(Bs) - 1, Peer, 5)
+                            end,
+                            50);
                 true ->
                     %{ok, Bs2} = Bs,
-                    %io:fwrite("blocks are "),
+                    io:fwrite("got blocks "),
+                    io:fwrite(integer_to_list(N)),
+                    io:fwrite("\n"),
                     %sync_kill:stop(),
-                    Dict = binary_to_term(zlib:uncompress(Bs)),
+                    %Dict = binary_to_term(zlib:uncompress(Bs)),
+                    Dict = block_db:uncompress(Bs),
                     %io:fwrite(packer:pack(dict:fetch(hd(dict:fetch_keys(Dict)), Dict))),
                     %io:fwrite("\n"),
                     L = low_to_high(dict_to_blocks(dict:fetch_keys(Dict), Dict)),
+                    %spawn(fun() ->
+                    %              block_organizer:add(L)
+                    %      end),
                     S = length(L),
                     Cores = 1,
                     S2 = S div Cores,
-                    CurrentHeight = block:height(),
+                    %CurrentHeight = block:height(),
                     %io:fwrite("get blocks 2, sync blocks part 2\n"),
                     %io:fwrite(integer_to_list(N)),
                     %io:fwrite("\n"),
                     split_add(S2, Cores, L),
                     %timer:sleep(500),
                     %sync_kill:start(),
-                    %CurrentHeight = block:height(),
-
-                    %wait_do(fun() ->
-                    %                CurrentHeight = block:height(),
-                    %                (N + length(L)) < (CurrentHeight + 2000)
-                    %        end,
-                    %        fun() ->
-                    %                get_blocks2(TheirBlockHeight, BB, N + length(L)+1, Peer, 1)
-                    %        end,
-                    %        50),
+                    CurrentHeight = block:height(),
+                    wait_do(fun() ->
+                                    (N + length(L)) < (block:height() + 8000)
+                            end,
+                            fun() ->
+                                    %io:fwrite("wait do call \n"),
+                                    get_blocks2(TheirBlockHeight, BB, N + length(L)+1, Peer, 5)
+                            end,
+                            50),
+                    CurrentHeight = block:height(),
                     if
-                    %    true -> ok;
-                        ((N + length(L)) < (CurrentHeight + 3000)) ->
-                            get_blocks2(TheirBlockHeight, BB, N + length(L)+1, Peer, 5);
+                        true -> ok;
+                        ((N + length(L)) < (CurrentHeight + 5000)) ->
+                            get_blocks2(TheirBlockHeight, BB, N + length(L)+100, Peer, 5);
                         true -> ok
                     end
 
@@ -332,12 +352,18 @@ get_blocks2(TheirBlockHeight, BB, N, Peer, Tries) ->
                         %io:fwrite("\n"),
                     %block_organizer:add(binary_to_term(zlib:uncompress(Bs2)))
             end;
-	_ -> block_organizer:add(Blocks)
+	_ -> 
+            io:fwrite("bad unused"),
+            1=2,
+            block_organizer:add(Blocks)
     end.
 wait_do(FB, F, T) ->
+    go = sync_kill:status(),
     B = FB(),
     if
-        B -> F();
+        B -> 
+            %io:fwrite("wait do done waiting \n"),
+            F();
         true ->
             timer:sleep(T),
             wait_do(FB, F, T)
diff --git a/apps/amoveo_core/src/consensus/trees/oracle_bets.erl b/apps/amoveo_core/src/consensus/trees/oracle_bets.erl
index 6daca5e..b92cb33 100644
--- a/apps/amoveo_core/src/consensus/trees/oracle_bets.erl
+++ b/apps/amoveo_core/src/consensus/trees/oracle_bets.erl
@@ -97,9 +97,9 @@ dict_add_bet(Pub, OID, Type, Amount, Dict) ->%changed%
     A = accounts:dict_get(Pub, Dict),%
     case A of%
 	empty -> %
-	    io:fwrite("account does not exist\n"),%
-	    io:fwrite(base64:encode(Pub)),%
-	    io:fwrite("\n"),%
+	    %io:fwrite("account does not exist\n"),%
+	    %io:fwrite(base64:encode(Pub)),%
+	    %io:fwrite("\n"),%
 	    Dict;%
 	_ ->%
 	    X = dict_get({key, Pub, OID}, Dict),%
diff --git a/apps/amoveo_http/src/talker.erl b/apps/amoveo_http/src/talker.erl
index 680bfb7..cc3e15d 100644
--- a/apps/amoveo_http/src/talker.erl
+++ b/apps/amoveo_http/src/talker.erl
@@ -11,7 +11,7 @@ talk(Msg, {IP, Port}) ->
     talk(Msg, build_string_peer(IP, Port));
 
 talk(Msg, Peer) ->
-    talk_helper(Msg, Peer, ?RETRY, 20000).
+    talk_helper(Msg, Peer, ?RETRY, 60000).
 
 talk(Msg, IP, Port) ->
     talk(Msg, build_string_peer(IP, Port)).
