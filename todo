when making and processing blocks, we need to verify the proof, and then later on the proof gets written into the database, once we are sure the entire block is correct.
So, in between time, we stuck the proof into a dictionary structure. This seems like it was a bad idea, because it gets dropped from the dictionary somewhere.
we need a better plan.
maybe the functions should be updated to pass this proof around seperate from the dict, and before the hard update they can pass around a zero.
Another option is to prevent the proof from getting dropped from the dict.


tree_data:verkle_dict_update_trie
is is currently writing the new data directly to the hard drive. it should be updating the verkle proof and calculating the new root all in ram first.


verify_verkle:leaves is returning empty slots like {I, 0}, where I is the pointer to the next step.
but, without context, I doesn't mean anything. What we really want is the key that is pointing to emptiness.


failing to sync any blocks. the root hash doesn't match.

trees2:prove is failing when we try to prove the non-existence of elements. we should make a smaller test to show this, and then fix it.
trees2:test(4) is this test.

the problem now is that we want to use the more generic form trees:get/2 in more places, because this is the version we are updating for the hard update.
but, it returns everything in object format {acc, BAlance, Nonce}, except for gov values. which it returns as the integer directly.



for every tree, we need to update dict_get to understand the new serialization.
oracle, matched, unmatched, sub_acc, contract, trade, market, receipt.




not calculating the market cap right with this new database format.


in block.erl, line 824.
problem with loading the dict from the verkle proof.




* switch over all the governance values to be hard coded instead of in the database.
  - proofs:txs_to_querys shouldn't include governance stuff after the update. Done
  - trees:get/4 with tag governance should be hard coded. Done
  - trees:get/2 with governance as well. Done
  - governance:dict_get_value/2 should return hard coded values after the hard update. (and so it needs to know what height it is being called from.) Done
  - don't bother storing them in the block, but do store the period in the headers. Done


* use the new db when processing blocks.
  - tree_data:internal_dict_update_trie/2 should work if Trees is a pointer to the verkle root. Just load everything from the Dict as a batch. So it needs to know the height.
    Done, should be tested by mining and syncing some blocks, and confirming that the trees data is replaced with a single pointer, and roots with a single hash.
  - in block:make, we use trees:root_hash. this should be updated to work with a pointer to the verkle tree.
    Done. verify by mining and syncing some blocks.
    
  - proofs:prove(Querys, Trees) should work if the Trees is a pointer to the verkle tree. it should make a verkle proof.
    Done. we need to test that it works somehow.

  - proofs:facts_to_dict needs to work with the verkle proof.
    Write when the test reaches this point. print statement is ready.





* use the new db when making proofs for the api.
  - make a new api that accepts batches of things that we want proved.

* make sure the state root in the header is being calculated reasonably. Look at what block:merkelize is doing to the proofs in the block.


  
* use the new db when generating bocks.
  - block:hash should work with the new format of trees and roots.

* in block_db, instead of storing proofs for every block on a page, store a single proof for all the consensus state you need to verify that entire page.
  - replace the proofs in the blocks with the merkle root of that proof.
  - block hash should work, even if you don't re-create the verkle proof for that block.
  - teach the syncing node how to handle this.


* make sure serializing to json for http works, and that the light node can verify the proofs.

* update the light node to use the new api after the change is activated.

* block access to the old tree after the update.

* set the correct update height.
