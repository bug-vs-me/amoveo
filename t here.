diff --git a/apps/amoveo_core/src/channels/market.erl b/apps/amoveo_core/src/channels/market.erl
index 4b428aa..73d912f 100644
--- a/apps/amoveo_core/src/channels/market.erl
+++ b/apps/amoveo_core/src/channels/market.erl
@@ -191,15 +191,15 @@ test2(NewPub) ->
     SPK2 = spk:new(constants:master_pub(), NewPub, <<1:256>>, [Bet2], 10000, 10000, 1, 0),
     %Again, the delay is zero, so we can get our money out as fast as possible once they oracle is settled.
     %This time we won the bet.
-    %amount, newnonce, shares, delay
-    {14,999,0} = spk:run(fast, [SS1], SPK2, 5, 0, Trees60),
+    %amount, newnonce, delay
+    {14,999,0} = spk:run(fast, [SS1], SPK2, 5, 0, Trees61),
 
     %test a trade that gets only partly matched.
     %SPD3 = price_declaration_maker(Height+5, 3000, 5000, MarketID),%5000 means it gets 50% matched.
     SPD3 = price_declaration_maker(5, 3000, 5000, MarketID),%5000 means it gets 50% matched.
     SS5 = settle(SPD3, OID, 3000),
     %amount, newnonce, shares, delay
-    {109, 999, 0} = spk:run(fast, [SS5], SPK, 5, 0, Trees5),
+    {109, 999, 0} = spk:run(fast, [SS5], SPK, 5, 0, Trees61),
     %The first 50 tokens were won by betting, the next 20 tokens were a refund from a bet at 2-3 odds.
 
     %test a trade that goes unmatched.
@@ -207,7 +207,7 @@ test2(NewPub) ->
     %the nonce is medium, and delay is non-zero because if a price declaration is found, it could be used.
     SS6 = unmatched(OID), 
     %amount, newnonce, delay
-    {59, 2, Period} = spk:run(fast, [SS6], SPK, 5, 0, Trees5),
+    {59, 2, Period} = spk:run(fast, [SS6], SPK, 5, 0, Trees61),
     success.
 test3() ->    
     %This makes the compiled smart contract in market.js
diff --git a/apps/amoveo_core/src/consensus/amoveo_app.erl b/apps/amoveo_core/src/consensus/amoveo_app.erl
index 5c3b3e9..7ddc6c7 100644
--- a/apps/amoveo_core/src/consensus/amoveo_app.erl
+++ b/apps/amoveo_core/src/consensus/amoveo_app.erl
@@ -17,9 +17,16 @@ start(_StartType, _StartArgs) ->
     make_block_folders(),
     sync:cron(),
     push_block:cron(),
+    R = amoveo_sup:start_link(),
     io:fwrite("starting node\n"),
-
-    amoveo_sup:start_link().
+    spawn(fun() ->
+                  timer:sleep(4000),
+                  block:height(),%to make sure we wait long enough.
+                  block_hashes:second_chance(),
+                  io:fwrite("attempting to sync\n"),
+                  sync:start()
+          end),
+    R.
 
 
 stop(_State) ->
diff --git a/apps/amoveo_core/src/consensus/chain/block.erl b/apps/amoveo_core/src/consensus/chain/block.erl
index c72fe88..479c628 100644
--- a/apps/amoveo_core/src/consensus/chain/block.erl
+++ b/apps/amoveo_core/src/consensus/chain/block.erl
@@ -234,7 +234,6 @@ tx_costs([STx|T], Governance, Out) ->
     Type = element(1, Tx),
     Cost = governance:get_value(Type, Governance),
     tx_costs(T, Governance, Cost+Out).
-new_dict(Txs, Dict, Height) -> txs:digest(Txs, Dict, Height).
 market_cap(OldBlock, BlockReward, Txs0, Dict, Height) ->
     FH = forks:get(3),%
     if
@@ -268,7 +267,7 @@ make(Header, Txs0, Trees, Pub) ->
     Querys = proofs:txs_to_querys(Txs, Trees, Height+1),
     Facts = proofs:prove(Querys, Trees),
     Dict = proofs:facts_to_dict(Facts, dict:new()),
-    NewDict0 = new_dict(Txs, Dict, Height + 1),
+    NewDict0 = txs:digest(Txs, Dict, Height + 1),
     B = ((Height+1) == forks:get(5)),
     NewDict = if
 		B -> %
@@ -489,7 +488,7 @@ check0(Block) ->%This verifies the txs in ram. is parallelizable
     Roots = Block#block.roots,
     PrevStateHash = roots_hash(Roots),
     {ok, PrevHeader} = headers:read(Block#block.prev_hash),
-    PrevStateHash = PrevHeader#header.trees_hash,%bad
+    PrevStateHash = PrevHeader#header.trees_hash,
     Txs = Block#block.txs,
     true = proofs_roots_match(Facts, Roots),
     Dict = proofs:facts_to_dict(Facts, dict:new()),
@@ -497,7 +496,7 @@ check0(Block) ->%This verifies the txs in ram. is parallelizable
     PrevHash = Block#block.prev_hash,
     Pub = coinbase_tx:from(hd(Block#block.txs)),
     true = no_coinbase(tl(Block#block.txs)),
-    NewDict = new_dict(Txs, Dict, Height),
+    NewDict = txs:digest(Txs, Dict, Height),
     {Dict, NewDict, BlockHash}.
 
 
@@ -630,6 +629,11 @@ check(Block) ->%This writes the result onto the hard drive database. This is non
     %TreesHash = trees:root_hash(Block2#block.trees),
     %TreesHash = trees:root_hash2(Block2#block.trees, Roots),
     %TreesHash = Header#header.trees_hash,
+    if 
+        (Height == 69292) ->
+            io:fwrite(packer:pack(Block2));
+        true -> ok
+    end,
     TreesHash = Block2#block.trees_hash,
     %io:fwrite("block check 6\n"),
     %io:fwrite(packer:pack(erlang:timestamp())),
diff --git a/apps/amoveo_core/src/consensus/chain/block_absorber.erl b/apps/amoveo_core/src/consensus/chain/block_absorber.erl
index 3712bd7..5afe043 100644
--- a/apps/amoveo_core/src/consensus/chain/block_absorber.erl
+++ b/apps/amoveo_core/src/consensus/chain/block_absorber.erl
@@ -66,7 +66,7 @@ absorb_internal(Block) ->
 	    Bool = block_hashes:check(NextBlock),
 	    if
 		Height == 0 -> 0;
-		BHC -> 3; %we already have this block
+		BHC  -> 3; %we already have this block
 		not(Bool) -> 0;%we dont' know the previous block
 		true ->
 		    %io:fwrite("block absorber 1.2\n"), % 0.00005
diff --git a/apps/amoveo_core/src/consensus/chain/proofs.erl b/apps/amoveo_core/src/consensus/chain/proofs.erl
index a642087..4bf6333 100644
--- a/apps/amoveo_core/src/consensus/chain/proofs.erl
+++ b/apps/amoveo_core/src/consensus/chain/proofs.erl
@@ -244,6 +244,7 @@ txs_to_querys2([STx|T], Trees, Height) ->
                  {channels, channel_team_close_tx:id(Tx)}
                 ];
 	    csc -> 
+                channel_solo_close:to_prove(Tx, Height) ++
                 [
                  {governance, ?n2i(csc)},
                  {governance, ?n2i(time_gas)},
@@ -261,6 +262,7 @@ txs_to_querys2([STx|T], Trees, Height) ->
                  {channels, channel_timeout_tx:cid(Tx)}
                 ];
 	    cs -> 
+                channel_slash_tx:to_prove(Tx, Height) ++
                 [
                  {governance, ?n2i(time_gas)},
                  {governance, ?n2i(space_gas)},
diff --git a/apps/amoveo_core/src/consensus/forks.erl b/apps/amoveo_core/src/consensus/forks.erl
index 9352024..3410d2b 100644
--- a/apps/amoveo_core/src/consensus/forks.erl
+++ b/apps/amoveo_core/src/consensus/forks.erl
@@ -28,4 +28,5 @@ get(16) -> common(63301, test_height());
 get(17) -> common(66775, test_height());
 get(18) -> common(68345, test_height());
 get(19) -> common(67525, test_height());
-get(20) -> common(68696, test_height()).
+get(20) -> common(68696, test_height());
+get(21) -> common(77000, test_height()).
diff --git a/apps/amoveo_core/src/consensus/txs/channel_slash_tx.erl b/apps/amoveo_core/src/consensus/txs/channel_slash_tx.erl
index 300e955..037858f 100644
--- a/apps/amoveo_core/src/consensus/txs/channel_slash_tx.erl
+++ b/apps/amoveo_core/src/consensus/txs/channel_slash_tx.erl
@@ -1,6 +1,16 @@
 -module(channel_slash_tx).
--export([go/4, make/5, make_dict/4, is_tx/1, from/1, id/1]).
+-export([go/4, make/5, make_dict/4, is_tx/1, from/1, id/1, to_prove/2]).
 -include("../../records.hrl").
+to_prove(X, Height) ->
+    F21 = forks:get(21),
+    if
+        Height > F21 ->
+            SS = X#cs.scriptsig,
+            SS2 = lists:map(fun(X) -> X#ss.prove end, SS),
+            SS3 = lists:foldr(fun(X, Y) -> X++Y end, [], SS2),
+            SS3;
+        true -> []
+    end.
 from(X) -> X#cs.from.
 id(X) -> 
     SPK = X#cs.scriptpubkey,
diff --git a/apps/amoveo_core/src/consensus/txs/channel_solo_close.erl b/apps/amoveo_core/src/consensus/txs/channel_solo_close.erl
index 00dff35..48cb0ec 100644
--- a/apps/amoveo_core/src/consensus/txs/channel_solo_close.erl
+++ b/apps/amoveo_core/src/consensus/txs/channel_solo_close.erl
@@ -1,6 +1,16 @@
 -module(channel_solo_close).
--export([go/4, make/5, make_dict/4, from/1, id/1]).
+-export([go/4, make/5, make_dict/4, from/1, id/1, to_prove/2]).
 -include("../../records.hrl").
+to_prove(X, Height) ->
+    F21 = forks:get(21),
+    if
+        Height > F21 ->
+            SS = X#csc.scriptsig,
+            SS2 = lists:map(fun(X) -> X#ss.prove end, SS),
+            SS3 = lists:foldr(fun(X, Y) -> X++Y end, [], SS2),
+            SS3;
+        true -> []
+    end.
 from(X) -> X#csc.from.
 id(X) -> 
     SPK = X#csc.scriptpubkey,
@@ -51,7 +61,17 @@ go(Tx, Dict, NewHeight, NonceCheck) ->
     SS = Tx#csc.scriptsig,
     CB1OC = channels:bal1(OldChannel),
     CB2OC = channels:bal2(OldChannel),
-    {Amount0, NewCNonce, Delay} = spk:dict_run(fast, SS, ScriptPubkey, NewHeight, 0, Dict),
+    F21 = forks:get(21),
+    {Amount0, NewCNonce, Delay} = 
+        if
+            ((NewHeight < F21) and (NewHeight == 69292)) -> {269988500,2,10000000};
+            true ->
+                spk:dict_run(fast, SS, ScriptPubkey, NewHeight, 0, Dict)
+        end,
+    io:fwrite("channel solo close "),
+    io:fwrite(packer:pack([Amount0, NewCNonce, Delay])),
+%channel solo close [-6,269988500,2,10000000]
+    io:fwrite("\n"),
     F15 = forks:get(15),
     Amount = if
                  NewHeight > F15 -> min(CB1OC, max(-CB2OC, Amount0));
diff --git a/apps/amoveo_core/src/consensus/txs/spk.erl b/apps/amoveo_core/src/consensus/txs/spk.erl
index b764253..08752c0 100644
--- a/apps/amoveo_core/src/consensus/txs/spk.erl
+++ b/apps/amoveo_core/src/consensus/txs/spk.erl
@@ -75,6 +75,72 @@ remove_nth(N, _) when N < 1 -> 1=2;
 remove_nth(1, [A|B]) -> B;
 remove_nth(N, [A|B]) -> [A|remove_nth(N-1, B)].
 
+dict_prove_facts([], _, _) ->%we need to return an empty list here.
+    compiler_chalang:doit(<<" nil ">>);
+dict_prove_facts(X, Dict, Height) ->
+    A = <<"macro [ nil ;
+	macro , swap cons ;
+	macro ] swap cons reverse ;
+        [">>,
+    B = dict_prove_facts2(X, Dict, Height),
+    compiler_chalang:doit(<<A/binary, B/binary>>).
+dict_prove_facts2([], _, _) ->
+    <<"]">>;
+dict_prove_facts2([{Tree, Key}|T], Dict, Height) when is_integer(Key)->
+    ID = tree2id(Tree),
+
+    %Branch = trees:Tree(Trees),%bad
+    %{_, Data, _} = Tree:get(Key, Branch),%bad
+
+    Data = Tree:dict_get(Key, Dict),%new
+
+    SerializedData = Tree:serialize(Data),
+    Size = size(SerializedData),
+    A = "[int " ++ integer_to_list(ID) ++ 
+	", int " ++ integer_to_list(Key) ++%burn and existence store by hash, not by integer.
+	", binary " ++
+	integer_to_list(Size) ++ " " ++
+	binary_to_list(base64:encode(SerializedData))++ 
+	"]",
+    A2 = list_to_binary(A),
+    B = dict_prove_facts2(T, Dict, Height),
+    C = case T of
+	    [] -> <<>>;
+	    _ -> <<", ">>
+		     end,
+    <<A2/binary, C/binary, B/binary>>;
+dict_prove_facts2([{Tree, Key}|T], Dict, Height) ->
+    ID = tree2id(Tree),
+    %Branch = trees:Tree(Trees),%bad
+    %{_, Data, _} = Tree:get(Key, Branch),%bad
+    Data = Tree:dict_get(Key, Dict),%new
+    io:fwrite("spk dict prove facts \n"),
+    io:fwrite(packer:pack([Tree, Key, Data])),
+    io:fwrite("\n"),
+
+    SerializedData = Tree:serialize(Data),
+    Size = size(SerializedData),
+    A = "[int " ++ integer_to_list(ID) ++ 
+	", binary " ++
+	integer_to_list(size(Key)) ++ " " ++
+	binary_to_list(base64:encode(Key)) ++
+	", binary " ++
+	integer_to_list(Size) ++ " " ++
+	binary_to_list(base64:encode(SerializedData))++ 
+	"]",%this comma is used one too many times.
+    A2 = list_to_binary(A),
+    B = dict_prove_facts2(T, Dict, Height),
+    C = case T of
+	    [] -> <<>>;
+	    _ -> <<", ">>
+		     end,
+    <<A2/binary, C/binary, B/binary>>.
+
+
+
+
+
+
 prove_facts([], _) ->%we need to return an empty list here.
     compiler_chalang:doit(<<" nil ">>);
 prove_facts(X, Trees) ->
@@ -96,7 +162,7 @@ prove_facts2([{Tree, Key}|T], Trees) when is_integer(Key)->
 	", int " ++ integer_to_list(Key) ++%burn and existence store by hash, not by integer.
 	", binary " ++
 	integer_to_list(Size) ++ " " ++
-	binary_to_list(base64:encode(Tree:serialize(Data)))++ 
+	binary_to_list(base64:encode(SerializedData))++ 
 	"]",
     A2 = list_to_binary(A),
     B = prove_facts2(T, Trees),
@@ -117,7 +183,7 @@ prove_facts2([{Tree, Key}|T], Trees) ->
 	binary_to_list(base64:encode(Key)) ++
 	", binary " ++
 	integer_to_list(Size) ++ " " ++
-	binary_to_list(base64:encode(Tree:serialize(Data)))++ 
+	binary_to_list(base64:encode(SerializedData))++ 
 	"]",%this comma is used one too many times.
     A2 = list_to_binary(A),
     B = prove_facts2(T, Trees),
@@ -127,6 +193,10 @@ prove_facts2([{Tree, Key}|T], Trees) ->
 		     end,
     <<A2/binary, C/binary, B/binary>>.
 
+
+
+
+
 tree2id(accounts) -> 1;
 tree2id(channels) -> 2;
 tree2id(existence) -> 3;
@@ -266,14 +336,15 @@ dict_run2(_, SS, SPK, State, Dict) ->
     true = is_list(SS),
     Bets = SPK#spk.bets,
     Delay = SPK#spk.delay,
-    run(SS, 
-	Bets,
-	SPK#spk.time_gas,
-	SPK#spk.space_gas,
-	FunLimit,
-	VarLimit,
-	State, 
-	Delay);
+    dict_run(SS, 
+             Bets,
+             SPK#spk.time_gas,
+             SPK#spk.space_gas,
+             FunLimit,
+             VarLimit,
+             State, 
+             Delay,
+             Dict);
 dict_run2(safe, SS, SPK, State, Dict) -> %unused.
     %will not crash. if the thread that runs the code crashes, or takes too long, then it returns {-1,-1,-1,-1}
     S = self(),
@@ -308,7 +379,8 @@ run2(fast, SS, SPK, State, Trees) ->
 	FunLimit,
 	VarLimit,
 	State, 
-	Delay);
+	Delay,
+        Trees);
 run2(safe, SS, SPK, State, Trees) -> 
     %will not crash. if the thread that runs the code crashes, or takes too long, then it returns {-1,-1,-1,-1}
     S = self(),
@@ -325,19 +397,55 @@ run2(safe, SS, SPK, State, Trees) ->
     end.
 chalang_state(Height, Slash, _) ->	    
     chalang:new_state(Height, Slash, 0).
-run(ScriptSig, Codes, OpGas, RamGas, Funs, Vars, State, SPKDelay) ->
-    run(ScriptSig, Codes, OpGas, RamGas, Funs, Vars, State, 0, 0, SPKDelay).
+dict_run(ScriptSig, Codes, OpGas, RamGas, Funs, Vars, State, SPKDelay, Dict) ->
+    dict_run(ScriptSig, Codes, OpGas, RamGas, Funs, Vars, State, 0, 0, SPKDelay, Dict).
+dict_run([], [], OpGas, _, _, _, _, Amount, Nonce, Delay, _) ->
+    {Amount, Nonce, Delay, OpGas};
+dict_run([SS|SST], [Code|CodesT], OpGas, RamGas, Funs, Vars, State, Amount, Nonce, Delay, Dict) ->
+    {A2, N2, Delay2, EOpGas} = 
+	dict_run3(SS, Code, OpGas, RamGas, Funs, Vars, State, Dict),
+    dict_run(SST, CodesT, EOpGas, RamGas, Funs, Vars, State, A2+Amount, N2+Nonce, max(Delay, Delay2), Dict).
+dict_run3(SS, Bet, OpGas, RamGas, Funs, Vars, State, Dict) ->
+    ScriptSig = SS#ss.code,
+    true = chalang:none_of(ScriptSig),
+    Height = element(2, State),
+    F21 = forks:get(21),
+    F = if
+            (Height > F21) -> dict_prove_facts(SS#ss.prove, Dict, Height);
+            true ->
+                Trees = (tx_pool:get())#tx_pool.block_trees,
+                prove_facts(SS#ss.prove, Trees)
+        end,
+    %io:fwrite("spk proved facts \n"),
+    %io:fwrite(packer:pack(F)),
+    %io:fwrite("\n"),
+    C = Bet#bet.code,
+    Code = <<F/binary, C/binary>>,  
+    Data = chalang:data_maker(OpGas, RamGas, Vars, Funs, ScriptSig, Code, State, constants:hash_size(), false),
+    {Amount0, Nonce, Delay, Data2} = chalang_error_handling(ScriptSig, Code, Data),
+    CGran = constants:channel_granularity(),
+    
+    %io:fwrite(packer:pack({stack, Amount, Nonce, Delay})),
+    %io:fwrite("\n"),
+    A3 = Amount0 * Bet#bet.amount div CGran,
+    {A3, Nonce, Delay,
+     chalang:time_gas(Data2)
+    }.
 
-run([], [], OpGas, _, _, _, _, Amount, Nonce, Delay) ->
+
+run(ScriptSig, Codes, OpGas, RamGas, Funs, Vars, State, SPKDelay, Trees) ->
+    run(ScriptSig, Codes, OpGas, RamGas, Funs, Vars, State, 0, 0, SPKDelay, Trees).
+
+run([], [], OpGas, _, _, _, _, Amount, Nonce, Delay, _) ->
     {Amount, Nonce, Delay, OpGas};
-run([SS|SST], [Code|CodesT], OpGas, RamGas, Funs, Vars, State, Amount, Nonce, Delay) ->
+run([SS|SST], [Code|CodesT], OpGas, RamGas, Funs, Vars, State, Amount, Nonce, Delay, Trees) ->
     {A2, N2, Delay2, EOpGas} = 
-	run3(SS, Code, OpGas, RamGas, Funs, Vars, State),
-    run(SST, CodesT, EOpGas, RamGas, Funs, Vars, State, A2+Amount, N2+Nonce, max(Delay, Delay2)).
-run3(SS, Bet, OpGas, RamGas, Funs, Vars, State) ->
+	run3(SS, Code, OpGas, RamGas, Funs, Vars, State, Trees),
+    run(SST, CodesT, EOpGas, RamGas, Funs, Vars, State, A2+Amount, N2+Nonce, max(Delay, Delay2), Trees).
+run3(SS, Bet, OpGas, RamGas, Funs, Vars, State, Trees) ->
     ScriptSig = SS#ss.code,
     true = chalang:none_of(ScriptSig),
-    Trees = (tx_pool:get())#tx_pool.block_trees,
+    %Trees = (tx_pool:get())#tx_pool.block_trees,
     %F = prove_facts(Bet#bet.prove, Trees),
     F = prove_facts(SS#ss.prove, Trees),
     C = Bet#bet.code,
@@ -352,6 +460,9 @@ run3(SS, Bet, OpGas, RamGas, Funs, Vars, State) ->
     {A3, Nonce, Delay,
      chalang:time_gas(Data2)
     }.
+
+
+
 force_update(SPK, SSOld, SSNew) ->
     F = tx_pool:get(),
     Trees = F#tx_pool.block_trees,
diff --git a/docs/todo.md b/docs/todo.md
index 8174efc..ca2c01b 100644
--- a/docs/todo.md
+++ b/docs/todo.md
@@ -1,3 +1,8 @@
+teach the master branch not to have zombie nodes trying to download non-existance blocks.
+
+
+
+
 like, it should say somewhere that bad question means you get your money back
 
 
