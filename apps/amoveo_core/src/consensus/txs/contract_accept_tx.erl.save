-module(contract_accept_tx).
-export([go/4, make_offer/8, make_dict/4,
         acc1/1, acc2/1]).
-include("../../records.hrl").

%-record(contract_offer, {contract_id, amount, pub, types}).%types is like [{0, Portion1},{2, Portion2}], where the integer is the type that the offerer wants to control, and amount is the portion of it that they want to control.
%-record(contract_accept_tx, {from, nonce fee, signed_offer}).

acc1(Tx) ->
    #contract_accept_tx{
      from = From
     } = Tx,
    From.
acc2(X) ->
    #contract_offer{
      from = From
     } = X,
    From.

make_dict(Pub, NCOffer, Fee, SPK) ->
    NCO = testnet_sign:data(NCOffer),
    CH = NCO#contract_offer.contract_id,
    CS = spk:sign(SPK, 2),%should be signed by acc2
    
    CH = spk:hash(SPK),

    Sig = if
              (element(3, CS) == []) -> 
                  element(2, element(4, CS));
              true -> 
                  element(2, element(3, CS))
          end,
    B1 = testnet_sign:verify_sig(CH, Sig, keys:pubkey()),

    %CS2 = setelement(3, setelement(2, CS, CH), Sig),
    %true = spk:verify_sig(CS),
    #contract_accept_tx{from = Pub, offer = NCOffer, fee = Fee, contract_sig = Sig}.
make_offer(CID, Pub, TimeLimit, Bal1, Bal2, Delay, MC, SPK) ->
    A = trees:get(accounts, Pub),
    Nonce = A#acc.nonce + 1,
    <<_:256>> = CID,
    CH = spk:hash(SPK),
    true = MC > 0,
    true = MC < 100001,
    #contract_offer{contract_id = CID, from = Pub, nlocktime = 0, delay = Delay, miner_commission = MC}.
				 
go(Tx, Dict, NewHeight, _) -> 
    true = NewHeight > forks:get(11),
    #contract_accept_tx{
                fee = Fee,
                offer = SNCO,
                contract_sig = CS
              } = Tx,
    ID0 = cid(Tx),
    Aid1 = acc1(Tx),
    Aid2 = acc2(Tx),
    %Fee = Tx#contract_accept_tx.fee,
    %NCO = SNCO#signed.data,
    #contract_offer{
               nlocktime = NLock,
               miner_commission = MC,
               contract_id = CH,
               nonce = Nonce
             } = SNCO#signed.data,
    F29 = forks:get(29),
    ID = if
             (NewHeight > F29) ->
                 new_channel_tx:salted_id(ID0, Aid1);
             true -> ID0
         end,
    %NCO = Tx#contract_accept_tx.contract_offer#signed.data,
    %NLock = NCO#contract_offer.nlocktime,
    true = ((NLock == 0) or (NewHeight < NLock)),
    DefaultFee = governance:dict_get_value(nc, Dict),
    %ToAcc1 = ((Fee) - (DefaultFee)) * (10000 div NCO#contract_offer.miner_commission), %this is how we can incentivize limit-order like behaviour.
    ToAcc1 = ((Fee) - (DefaultFee)) * (10000 div MC), %this is how we can incentivize limit-order like behaviour.
    %CS = Tx#contract_accept_tx.contract_sig,
    %CH = NCO#contract_offer.contract_id,
    true = testnet_sign:verify_sig(CH, CS, Aid2),
    %true = testnet_sign:verify(CS2),
    true = testnet_sign:verify(SNCO),
    empty = channels:dict_get(ID, Dict),
    false = Aid1 == Aid2,
    %Bal1 = bal2(Tx),%BAD
    F13 = forks:get(13),
    Bal1 = if
               NewHeight > F13 -> bal1(Tx);
               true -> bal2(Tx)
           end,
    true = Bal1 >= 0,
    Bal2 = bal2(Tx),
    true = Bal2 >= 0,
    Delay = delay(Tx),
    NewChannel = channels:new(ID, Aid1, Aid2, Bal1, Bal2, NewHeight, Delay),
    Dict2 = channels:dict_write(NewChannel, Dict),
    F17 = (NewHeight > forks:get(17)),
    %F17 = false,
    %Bool1 = ((NLock - NewHeight) < NCO#contract_offer.delay),
    %Bool2 = NLock > 0,
    %Bool3 = (NCO#contract_offer.nonce == 0),
    Nonce1 = if
                 F17 -> none;
                 true -> Nonce
             end,
    Acc1 = accounts:dict_update(Aid1, Dict, -Bal1+ToAcc1, Nonce1),
    Acc2 = accounts:dict_update(Aid2, Dict, -Bal2-Fee-ToAcc1, none),

    F26 = forks:get(26),
    if
        (NewHeight > F26) ->
            %we want Acc1 to be able to cancel his channel offer by making some other unrelated tx to increase his nonce.
            true = Acc1#acc.nonce == (Nonce-1);
        true -> ok
    end,

    Dict3 = accounts:dict_write(Acc1, Dict2),
    nc_sigs:store(ID, CS),
    accounts:dict_write(Acc2, Dict3).
